CS255

Briefly summarize the DriverPass project. Who was the client? What type of system did they want you to design?
- DriverPass was a client who wanted to introduce a web based learning platform to assist learners in passing their DMV driver exam. In addition to the 
	learning platform for the written protion, the client wanted abilities to create and edit in-person appointments for practice driving tests.
	The system was to marry the existing way of appointment creation via callers to this new, more modern web based experience.

What did you do particularly well?
- I felt as though I did a very good job with the diagrams and flow of each. I had minor mistakes here and there, but overall, my grasp on the design
	and execution of the diagrams were above my peers.

If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
- This is a fairly easy question for me. I would like to have improved my first document: CS255 Business Requirements Document. It definitely lacked 
	detail in some of the sections where if I would have thought them through a bit more, I would have had a more complete document. 

How did you interpret the user’s needs and implement them into your system design? Why is it so important to consider the user’s needs when designing?
	I look at each use case through the user's perspective. It is easy to lose that insight when dealing with the system as a whole, but when a
	conscious effort is made to see it, it improves the overall design and flow to be less hostile or unintuitive for the user. This can lead
	to the design being functional but unusable to the average user, thus causing the user base to diminish in the case of customers and reduce
	efficiency in the case of employee users.

How do you approach designing software? What techniques or strategies would you use in the future to analyze and design a system?
	I tried to start as simple as possible, taking only the essential, functional requirements into consideration, then once that foundation is
	formed, introduce the non-functional requirments. This ensured that the base function is present and nothing is overlooked. From there we can
	take an Object Oriented Programming perspective and extend from the base to create the non-functional requirements. I did falter from this 
	in a few cases where I lost track of all the functional requirements. This led to delays in getting documents and diagrams created where I 
	had to find a strategy to think of then sort the requirements. Therefore, A future strategy for myself would be to categorize everything 
	as much as possible first in a chart or list so it is much easier to sort through them to find the functional requirements that I build
	my foundation with.